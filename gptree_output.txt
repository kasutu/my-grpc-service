# Project Directory Structure:
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ command/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ command.mapper.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ command.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command-http.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command-publisher.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command.controller.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ command.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ content/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ content.mapper.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ content.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content-http.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content-publisher.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content.controller.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ content.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ generated/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ command.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ content/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ content.ts
‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ grpc-client.options.ts
‚îÇ   ‚îî‚îÄ‚îÄ main.ts
‚îú‚îÄ‚îÄ bun.lock
‚îú‚îÄ‚îÄ eslint.config.mjs
‚îú‚îÄ‚îÄ gptree_output.txt
‚îú‚îÄ‚îÄ nest-cli.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ proto.sh
‚îú‚îÄ‚îÄ tsconfig.build.json
‚îî‚îÄ‚îÄ tsconfig.json

# BEGIN FILE CONTENTS

# File: src/command/interfaces/command.mapper.ts

import {
  CommandPackage,
  SetClockOverride,
  RequestSystemReboot,
  UpdateNetworkConfig,
  RotateScreen,
  AckRequest,
} from 'src/generated/command/v1/command';

export class CommandMapper {
  static toCommandPackage(json: any): CommandPackage {
    return {
      commandId: json.command_id?.toString() ?? '',
      requiresAck: json.requires_ack ?? false,
      issuedAt: json.issued_at ?? new Date().toISOString(),
      setClock: json.set_clock
        ? this.toSetClockOverride(json.set_clock)
        : undefined,
      requestReboot: json.request_reboot
        ? this.toRequestSystemReboot(json.request_reboot)
        : undefined,
      updateNetwork: json.update_network
        ? this.toUpdateNetworkConfig(json.update_network)
        : undefined,
      rotateScreen: json.rotate_screen
        ? this.toRotateScreen(json.rotate_screen)
        : undefined,
    };
  }

  private static toSetClockOverride(json: any): SetClockOverride {
    return {
      simulatedTime: json.simulated_time ?? '',
    };
  }

  private static toRequestSystemReboot(json: any): RequestSystemReboot {
    return {
      delaySeconds: json.delay_seconds ?? 0,
    };
  }

  private static toUpdateNetworkConfig(json: any): UpdateNetworkConfig {
    return {
      newSsid: json.new_ssid ?? '',
      newPassword: json.new_password ?? '',
    };
  }

  // ADD THIS METHOD
  private static toRotateScreen(json: any): RotateScreen {
    return {
      orientation: json.orientation ?? 'auto',
      fullscreen: json.fullscreen ?? false,
    };
  }

  static toAckRequest(json: any): AckRequest {
    return {
      deviceId: json.device_id ?? '',
      commandId: json.command_id?.toString() ?? '',
      processedSuccessfully: json.processed_successfully ?? false,
      errorMessage: json.error_message ?? '',
    };
  }

  // Update return type to include rotateScreen
  static getCommandType(
    pkg: CommandPackage,
  ):
    | 'setClock'
    | 'requestReboot'
    | 'updateNetwork'
    | 'rotateScreen'
    | 'unknown' {
    if (pkg.setClock) return 'setClock';
    if (pkg.requestReboot) return 'requestReboot';
    if (pkg.updateNetwork) return 'updateNetwork';
    if (pkg.rotateScreen) return 'rotateScreen';
    return 'unknown';
  }
}


# File: src/command/v1/command.proto

syntax = "proto3";

package remote.v1;


service RemoteCommandService {
  rpc SubscribeCommands(SubscribeRequest) returns (stream CommandPackage);
  rpc AcknowledgeCommand(AckRequest) returns (AckResponse);
}

message SubscribeRequest {
  string device_id = 1;
}

// Strongly-typed command envelope
message CommandPackage {
  string command_id = 1;
  
  oneof command {
    SetClockOverride set_clock = 2;
    RequestSystemReboot request_reboot = 3;
    UpdateNetworkConfig update_network = 4;
    RotateScreen rotate_screen = 5;  // NEW
  }
  
  bool requires_ack = 6;
  string issued_at = 7;
}

// Explicit command definitions (no JSON parsing needed)
message SetClockOverride {
  string simulated_time = 1;  // ISO 8601, empty = reset to system time
}

message RotateScreen {
  string orientation = 1;  // "landscape", "portrait", "auto", "landscape_left", "landscape_right", "portrait_up", "portrait_down"
  bool fullscreen = 2;     // optional: also toggle fullscreen
}

message RequestSystemReboot {
  int32 delay_seconds = 1;
}

message UpdateNetworkConfig {
  string new_ssid = 1;
  string new_password = 2;
}

message AckRequest {
  string device_id = 1;
  string command_id = 2;
  bool processed_successfully = 3;
  string error_message = 4;
}

message AckResponse {
  bool accepted = 1;
}

# File: src/command/command-http.controller.ts

import { Controller, Post, Param, Body, Get } from '@nestjs/common';
import { CommandPublisherService } from './command-publisher.service';
import { CommandMapper } from 'src/command/interfaces/command.mapper';

@Controller('commands')
export class CommandHttpController {
  constructor(private readonly publisher: CommandPublisherService) {}

  @Get('devices')
  getConnectedDevices() {
    const devices = this.publisher.getConnectedDevices();
    return {
      count: devices.length,
      devices: devices.map((d) => ({
        device_id: d.deviceId,
        connected_at: d.connectedAt.toISOString(),
        last_activity: d.lastActivity.toISOString(),
        connected_for_seconds: Math.floor(
          (Date.now() - d.connectedAt.getTime()) / 1000,
        ),
      })),
    };
  }

  @Post('clock/:deviceId')
  setClock(@Param('deviceId') deviceId: string, @Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `clock-${Date.now()}`,
      requires_ack: true,
      issued_at: new Date().toISOString(),
      set_clock: {
        simulated_time: body.simulated_time ?? '',
      },
    });

    const success = this.publisher.sendCommand(deviceId, command);
    return {
      success,
      message: success
        ? `Clock command sent to ${deviceId}`
        : `Device ${deviceId} not connected`,
      commandId: command.commandId,
    };
  }

  @Post('reboot/:deviceId')
  rebootDevice(@Param('deviceId') deviceId: string, @Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `reboot-${Date.now()}`,
      requires_ack: true,
      issued_at: new Date().toISOString(),
      request_reboot: {
        delay_seconds: body.delay_seconds ?? 0,
      },
    });

    const success = this.publisher.sendCommand(deviceId, command);
    return {
      success,
      message: success
        ? `Reboot command sent to ${deviceId}`
        : `Device ${deviceId} not connected`,
      commandId: command.commandId,
    };
  }

  @Post('network/:deviceId')
  updateNetwork(@Param('deviceId') deviceId: string, @Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `network-${Date.now()}`,
      requires_ack: true,
      issued_at: new Date().toISOString(),
      update_network: {
        new_ssid: body.new_ssid ?? '',
        new_password: body.new_password ?? '',
      },
    });

    const success = this.publisher.sendCommand(deviceId, command);
    return {
      success,
      message: success
        ? `Network config sent to ${deviceId}`
        : `Device ${deviceId} not connected`,
      commandId: command.commandId,
    };
  }

  @Post('broadcast/clock')
  broadcastClock(@Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `clock-broadcast-${Date.now()}`,
      requires_ack: false,
      issued_at: new Date().toISOString(),
      set_clock: {
        simulated_time: body.simulated_time ?? '',
      },
    });

    this.publisher.broadcastCommand(command);
    return { success: true, message: 'Clock broadcast sent' };
  }

  @Get('stats')
  getStats() {
    return {
      connected_devices: this.publisher.getConnectedCount(),
    };
  }

  @Post('rotate/:deviceId')
  rotateScreen(@Param('deviceId') deviceId: string, @Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `rotate-${Date.now()}`,
      requires_ack: true,
      issued_at: new Date().toISOString(),
      rotate_screen: {
        orientation: body.orientation ?? 'auto',
        fullscreen: body.fullscreen ?? null,
      },
    });

    const success = this.publisher.sendCommand(deviceId, command);
    return {
      success,
      message: success
        ? `Rotate command sent to ${deviceId}`
        : `Device ${deviceId} not connected`,
      commandId: command.commandId,
      orientation: body.orientation,
    };
  }

  @Post('broadcast/rotate')
  broadcastRotate(@Body() body: any) {
    const command = CommandMapper.toCommandPackage({
      command_id: `rotate-broadcast-${Date.now()}`,
      requires_ack: false,
      issued_at: new Date().toISOString(),
      rotate_screen: {
        orientation: body.orientation ?? 'auto',
        fullscreen: body.fullscreen ?? null,
      },
    });

    this.publisher.broadcastCommand(command);
    return {
      success: true,
      message: 'Rotate broadcast sent',
      orientation: body.orientation,
    };
  }
}


# File: src/command/command-publisher.service.ts

import { Injectable, OnModuleDestroy } from '@nestjs/common';
import { Subject } from 'rxjs';
import { CommandPackage } from 'src/generated/command/v1/command';

interface DeviceInfo {
  deviceId: string;
  connectedAt: Date;
  lastActivity: Date;
}

@Injectable()
export class CommandPublisherService implements OnModuleDestroy {
  private readonly subscriptions = new Map<string, Subject<CommandPackage>>();
  private readonly deviceInfo = new Map<string, DeviceInfo>();
  private readonly pendingAcks = new Map<string, Set<string>>();

  subscribe(deviceId: string): Subject<CommandPackage> {
    if (this.subscriptions.has(deviceId)) {
      console.log(
        `‚ö†Ô∏è Device ${deviceId} already subscribed to commands, replacing`,
      );
      this.subscriptions.get(deviceId)?.complete();
    }

    const stream$ = new Subject<CommandPackage>();
    this.subscriptions.set(deviceId, stream$);

    // Track device info
    const now = new Date();
    this.deviceInfo.set(deviceId, {
      deviceId,
      connectedAt: now,
      lastActivity: now,
    });

    console.log(
      `üéÆ Device ${deviceId} subscribed to commands (total: ${this.subscriptions.size})`,
    );
    return stream$;
  }

  unsubscribe(deviceId: string) {
    console.log(`üëã Device ${deviceId} unsubscribed from commands`);
    this.subscriptions.delete(deviceId);
    this.deviceInfo.delete(deviceId);
    this.pendingAcks.delete(deviceId);
  }

  acknowledge(
    deviceId: string,
    commandId: string,
    success: boolean,
    errorMsg?: string,
  ) {
    console.log(
      `‚úÖ Command ack from ${deviceId} for ${commandId}: ${success ? 'success' : 'failed'}`,
    );
    if (!success && errorMsg) {
      console.error(`   Error: ${errorMsg}`);
    }

    // Update last activity
    const info = this.deviceInfo.get(deviceId);
    if (info) {
      info.lastActivity = new Date();
    }

    const devicePending = this.pendingAcks.get(deviceId);
    if (devicePending) {
      devicePending.delete(commandId);
    }
    return { accepted: true };
  }

  sendCommand(deviceId: string, commandPackage: CommandPackage) {
    const stream$ = this.subscriptions.get(deviceId);

    if (stream$ && !stream$.closed) {
      stream$.next(commandPackage);
      console.log(`üì§ Sent command ${commandPackage.commandId} to ${deviceId}`);

      // Update last activity
      const info = this.deviceInfo.get(deviceId);
      if (info) {
        info.lastActivity = new Date();
      }

      if (commandPackage.requiresAck) {
        if (!this.pendingAcks.has(deviceId)) {
          this.pendingAcks.set(deviceId, new Set());
        }
        this.pendingAcks.get(deviceId)?.add(commandPackage.commandId);
      }
      return true;
    }
    console.log(`‚ùå Device ${deviceId} not connected for commands`);
    return false;
  }

  broadcastCommand(commandPackage: CommandPackage) {
    console.log(
      `üì¢ Broadcasting command to ${this.subscriptions.size} devices`,
    );
    for (const [deviceId, stream$] of this.subscriptions) {
      if (!stream$.closed) {
        stream$.next(commandPackage);
        const info = this.deviceInfo.get(deviceId);
        if (info) {
          info.lastActivity = new Date();
        }
      }
    }
  }

  getConnectedCount(): number {
    return this.subscriptions.size;
  }

  // NEW: Get list of connected devices
  getConnectedDevices(): DeviceInfo[] {
    return Array.from(this.deviceInfo.values());
  }

  onModuleDestroy() {
    for (const [, stream$] of this.subscriptions) {
      stream$.complete();
    }
    this.subscriptions.clear();
    this.deviceInfo.clear();
  }
}


# File: src/command/command.controller.ts

import { Controller } from '@nestjs/common';
import { GrpcMethod } from '@nestjs/microservices';
import { Observable, Subject } from 'rxjs';
import { CommandPublisherService } from './command-publisher.service';
import {
  SubscribeRequest,
  CommandPackage,
  AckRequest,
  AckResponse,
} from 'src/generated/command/v1/command';

@Controller()
export class CommandController {
  constructor(private readonly publisher: CommandPublisherService) {}

  @GrpcMethod('RemoteCommandService')
  subscribeCommands(request: SubscribeRequest): Observable<CommandPackage> {
    const stream$ = this.publisher.subscribe(request.deviceId);

    stream$.subscribe({
      complete: () => {
        this.publisher.unsubscribe(request.deviceId);
      },
    });

    return stream$.asObservable();
  }

  @GrpcMethod('RemoteCommandService')
  acknowledgeCommand(request: AckRequest): AckResponse {
    return this.publisher.acknowledge(
      request.deviceId,
      request.commandId,
      request.processedSuccessfully,
      request.errorMessage,
    );
  }
}


# File: src/command/command.module.ts

import { Module } from '@nestjs/common';
import { CommandController } from './command.controller';
import { CommandPublisherService } from './command-publisher.service';
import { CommandHttpController } from './command-http.controller';

@Module({
  providers: [CommandPublisherService],
  controllers: [CommandController, CommandHttpController],
})
export class CommandModule {}


# File: src/content/interfaces/content.mapper.ts

import {
  ContentPackage,
  Content,
  TimeSlot,
  Campaign,
  MediaRef,
  Media,
} from 'src/generated/content/v1/content';

export class ContentMapper {
  static toContentPackage(json: any): ContentPackage {
    return {
      deliveryId: json.delivery_id?.toString() ?? '',
      requiresAck: json.requires_ack ?? false,
      content: this.toContent(json.content),
      media: (json.media ?? []).map((m: any) => this.toMedia(m)),
    };
  }

  private static toContent(json: any): Content {
    return {
      id: json.id ?? 0,
      hmacSignature: json.hmac_signature ?? '',
      createdAt: json.created_at ?? '',
      fallbackMediaRef: this.toMediaRef(json.fallback_media_ref),
      timeSlots: (json.time_slots ?? []).map((slot: any) =>
        this.toTimeSlot(slot),
      ),
    };
  }

  private static toTimeSlot(json: any): TimeSlot {
    return {
      id: json.id ?? '',
      startWindow: json.start_window ?? '',
      endWindow: json.end_window ?? '',
      campaigns: (json.campaigns ?? []).map((camp: any) =>
        this.toCampaign(camp),
      ),
    };
  }

  private static toCampaign(json: any): Campaign {
    return {
      id: json.id ?? '',
      index: json.index ?? 0,
      mediaId: json.media_id ?? '',
    };
  }

  private static toMediaRef(json: any): MediaRef {
    return {
      mediaId: json?.media_id ?? '',
    };
  }

  private static toMedia(json: any): Media {
    return {
      id: json.id ?? '',
      checksum: json.checksum ?? '',
      url: json.url ?? '',
    };
  }

  static toAckRequest(json: any) {
    return {
      deviceId: json.device_id ?? '',
      deliveryId: json.delivery_id?.toString() ?? '',
      processedSuccessfully: json.processed_successfully ?? false,
      errorMessage: json.error_message,
    };
  }
}


# File: src/content/v1/content.proto

// Copyright (c) Localize Technologies, Inc. All rights reserved.

// Used in communication with hydrogen nodes for content synchronization and control
// Connnection is long lived and bidirectional

syntax = "proto3";

package content.v1;

service ContentService {
  // Flutter calls this once to subscribe to content updates
  rpc Subscribe(SubscribeRequest) returns (stream ContentPackage);
  
  // Unary call for acknowledgments (simpler than bidirectional)
  rpc Acknowledge(AckRequest) returns (AckResponse);
}

message SubscribeRequest {
  string device_id = 1;
  string last_received_delivery_id = 2; // For resume/reconnect
}

message ContentPackage {
  string delivery_id = 1;
  Content content = 2;
  repeated Media media = 3;
  bool requires_ack = 4; // If true, client must acknowledge
}

message AckRequest {
  string device_id = 1;
  string delivery_id = 2;
  bool processed_successfully = 3;
  string error_message = 4; // If failed
}

message AckResponse {
  bool accepted = 1;
}

// Types

message Content {
  int64 id = 1;
  string hmac_signature = 2;
  repeated TimeSlot time_slots = 3;
  MediaRef fallback_media_ref = 4;
  string created_at = 5;
}

message TimeSlot {
  string id = 1;
  string start_window = 2;
  string end_window = 3;
  repeated Campaign campaigns = 4;
}

message Campaign {
  string id = 1;
  int32 index = 2;
  string media_id = 3;
}

message MediaRef {
  string media_id = 1;
}

message Media {
  string id = 1;
  string checksum = 2;
  string url = 3;
}

# File: src/content/content-http.controller.ts

import { Controller, Post, Param, Body, Get } from '@nestjs/common';
import { ContentPublisherService } from './content-publisher.service';
import { ContentMapper } from 'src/content/interfaces/content.mapper';
import { ContentPackage } from 'src/generated/content/v1/content';

@Controller('content')
export class ContentHttpController {
  constructor(private readonly publisher: ContentPublisherService) {}

  @Post('push/:deviceId')
  pushToDevice(@Param('deviceId') deviceId: string, @Body() body: any) {
    // Convert snake_case JSON to camelCase interface
    const contentPackage: ContentPackage = ContentMapper.toContentPackage(body);

    console.log(`Mapped deliveryId: ${contentPackage.deliveryId}`);

    const success = this.publisher.publishToDevice(deviceId, contentPackage);
    return {
      success,
      message: success
        ? `Pushed to ${deviceId}`
        : `Device ${deviceId} not connected`,
      mappedId: contentPackage.deliveryId,
    };
  }

  @Post('broadcast')
  broadcast(@Body() body: any) {
    const contentPackage = ContentMapper.toContentPackage(body);
    this.publisher.broadcast(contentPackage);
    return { success: true, message: 'Broadcast sent' };
  }

  @Get('stats')
  getStats() {
    return {
      connected_devices: this.publisher.getConnectedCount(),
    };
  }
}


# File: src/content/content-publisher.service.ts

import { Injectable, OnModuleDestroy } from '@nestjs/common';
import { Subject } from 'rxjs';
import { ContentPackage } from 'src/generated/content/v1/content';

@Injectable()
export class ContentPublisherService implements OnModuleDestroy {
  private readonly subscriptions = new Map<string, Subject<ContentPackage>>();
  private readonly pendingAcks = new Map<string, Set<string>>();

  subscribe(
    deviceId: string,
    lastDeliveryId?: string,
  ): Subject<ContentPackage> {
    // Cleanup existing subscription if present
    if (this.subscriptions.has(deviceId)) {
      console.log(
        `‚ö†Ô∏è Device ${deviceId} already subscribed, replacing connection`,
      );
      this.subscriptions.get(deviceId)?.complete();
    }

    const stream$ = new Subject<ContentPackage>();
    this.subscriptions.set(deviceId, stream$);

    console.log(
      `üì± Device ${deviceId} subscribed (total: ${this.subscriptions.size})`,
    );

    // Handle resume logic here if needed
    if (lastDeliveryId) {
      console.log(`üîÑ Resuming from delivery ${lastDeliveryId}`);
    }

    return stream$;
  }

  unsubscribe(deviceId: string) {
    console.log(`üëã Device ${deviceId} unsubscribed`);
    this.subscriptions.delete(deviceId);
    this.pendingAcks.delete(deviceId);
  }

  acknowledge(
    deviceId: string,
    deliveryId: string,
    success: boolean,
    errorMsg?: string,
  ) {
    console.log(
      `‚úÖ Ack from ${deviceId} for ${deliveryId}: ${success ? 'success' : 'failed'}`,
    );

    if (!success && errorMsg) {
      console.error(`   Error: ${errorMsg}`);
    }

    const devicePending = this.pendingAcks.get(deviceId);
    if (devicePending) {
      devicePending.delete(deliveryId);
    }

    return { accepted: true };
  }

  publishToDevice(deviceId: string, contentPackage: ContentPackage) {
    const stream$ = this.subscriptions.get(deviceId);

    if (stream$ && !stream$.closed) {
      stream$.next(contentPackage);
      console.log(`üì§ Published ${contentPackage.deliveryId} to ${deviceId}`);

      if (contentPackage.requiresAck) {
        if (!this.pendingAcks.has(deviceId)) {
          this.pendingAcks.set(deviceId, new Set());
        }
        this.pendingAcks.get(deviceId)?.add(contentPackage.deliveryId);
      }
      return true;
    } else {
      console.log(`‚ùå Device ${deviceId} not connected`);
      return false;
    }
  }

  broadcast(contentPackage: ContentPackage) {
    console.log(`üì¢ Broadcasting to ${this.subscriptions.size} devices`);
    for (const [deviceId, stream$] of this.subscriptions) {
      if (!stream$.closed) {
        stream$.next(contentPackage);
      }
    }
  }

  getConnectedCount(): number {
    return this.subscriptions.size;
  }

  onModuleDestroy() {
    // Cleanup all subscriptions on shutdown
    for (const [deviceId, stream$] of this.subscriptions) {
      stream$.complete();
    }
    this.subscriptions.clear();
  }
}


# File: src/content/content.controller.ts

import { Controller } from '@nestjs/common';
import { GrpcMethod } from '@nestjs/microservices';
import { Observable, Subject } from 'rxjs';
import { ContentPublisherService } from './content-publisher.service';
import {
  SubscribeRequest,
  ContentPackage,
  AckRequest,
  AckResponse,
} from 'src/generated/content/v1/content';

@Controller()
export class ContentController {
  constructor(private readonly publisher: ContentPublisherService) {}

  @GrpcMethod('ContentService')
  subscribe(request: SubscribeRequest): Observable<ContentPackage> {
    const stream$ = this.publisher.subscribe(
      request.deviceId,
      request.lastReceivedDeliveryId,
    );

    // Cleanup on disconnect
    stream$.subscribe({
      complete: () => {
        this.publisher.unsubscribe(request.deviceId);
      },
    });

    return stream$.asObservable();
  }

  @GrpcMethod('ContentService')
  acknowledge(request: AckRequest): AckResponse {
    return this.publisher.acknowledge(
      request.deviceId,
      request.deliveryId,
      request.processedSuccessfully,
      request.errorMessage,
    );
  }
}


# File: src/content/content.module.ts

import { Module } from '@nestjs/common';
import { ContentController } from './content.controller';
import { ContentHttpController } from './content-http.controller';
import { ContentPublisherService } from './content-publisher.service';

@Module({
  providers: [ContentPublisherService],
  controllers: [ContentController, ContentHttpController],
})
export class ContentModule {}


# File: src/generated/command/v1/command.ts

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.19.6
// source: command/v1/command.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface SubscribeRequest {
  deviceId: string;
}

/** Strongly-typed command envelope */
export interface CommandPackage {
  commandId: string;
  setClock?: SetClockOverride | undefined;
  requestReboot?: RequestSystemReboot | undefined;
  updateNetwork?:
    | UpdateNetworkConfig
    | undefined;
  /** NEW */
  rotateScreen?: RotateScreen | undefined;
  requiresAck: boolean;
  issuedAt: string;
}

/** Explicit command definitions (no JSON parsing needed) */
export interface SetClockOverride {
  /** ISO 8601, empty = reset to system time */
  simulatedTime: string;
}

export interface RotateScreen {
  /** "landscape", "portrait", "auto", "landscape_left", "landscape_right", "portrait_up", "portrait_down" */
  orientation: string;
  /** optional: also toggle fullscreen */
  fullscreen: boolean;
}

export interface RequestSystemReboot {
  delaySeconds: number;
}

export interface UpdateNetworkConfig {
  newSsid: string;
  newPassword: string;
}

export interface AckRequest {
  deviceId: string;
  commandId: string;
  processedSuccessfully: boolean;
  errorMessage: string;
}

export interface AckResponse {
  accepted: boolean;
}

export interface RemoteCommandServiceClient {
  subscribeCommands(request: SubscribeRequest): Observable<CommandPackage>;

  acknowledgeCommand(request: AckRequest): Observable<AckResponse>;
}

export interface RemoteCommandServiceController {
  subscribeCommands(request: SubscribeRequest): Observable<CommandPackage>;

  acknowledgeCommand(request: AckRequest): Promise<AckResponse> | Observable<AckResponse> | AckResponse;
}

export function RemoteCommandServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["subscribeCommands", "acknowledgeCommand"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RemoteCommandService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RemoteCommandService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const REMOTE_COMMAND_SERVICE_NAME = "RemoteCommandService";


# File: src/generated/content/v1/content.ts

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.19.6
// source: content/v1/content.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface SubscribeRequest {
  deviceId: string;
  /** For resume/reconnect */
  lastReceivedDeliveryId: string;
}

export interface ContentPackage {
  deliveryId: string;
  content?: Content | undefined;
  media: Media[];
  /** If true, client must acknowledge */
  requiresAck: boolean;
}

export interface AckRequest {
  deviceId: string;
  deliveryId: string;
  processedSuccessfully: boolean;
  /** If failed */
  errorMessage: string;
}

export interface AckResponse {
  accepted: boolean;
}

export interface Content {
  id: number;
  hmacSignature: string;
  timeSlots: TimeSlot[];
  fallbackMediaRef?: MediaRef | undefined;
  createdAt: string;
}

export interface TimeSlot {
  id: string;
  startWindow: string;
  endWindow: string;
  campaigns: Campaign[];
}

export interface Campaign {
  id: string;
  index: number;
  mediaId: string;
}

export interface MediaRef {
  mediaId: string;
}

export interface Media {
  id: string;
  checksum: string;
  url: string;
}

export interface ContentServiceClient {
  /** Flutter calls this once to subscribe to content updates */

  subscribe(request: SubscribeRequest): Observable<ContentPackage>;

  /** Unary call for acknowledgments (simpler than bidirectional) */

  acknowledge(request: AckRequest): Observable<AckResponse>;
}

export interface ContentServiceController {
  /** Flutter calls this once to subscribe to content updates */

  subscribe(request: SubscribeRequest): Observable<ContentPackage>;

  /** Unary call for acknowledgments (simpler than bidirectional) */

  acknowledge(request: AckRequest): Promise<AckResponse> | Observable<AckResponse> | AckResponse;
}

export function ContentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["subscribe", "acknowledge"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ContentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ContentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CONTENT_SERVICE_NAME = "ContentService";


# File: src/app.module.ts

import { Module } from '@nestjs/common';
import { ContentModule } from './content/content.module';
import { CommandModule } from './command/command.module';

@Module({
  imports: [ContentModule, CommandModule],
})
export class AppModule {}


# File: src/grpc-client.options.ts

import { ReflectionService } from '@grpc/reflection';
import { GrpcOptions, Transport } from '@nestjs/microservices';
import { join } from 'path';

export const grpcClientOptions: GrpcOptions = {
  transport: Transport.GRPC,
  options: {
    package: ['content.v1', 'remote.v1'], // Both packages
    protoPath: [
      join(__dirname, './content/v1/content.proto'),
      join(__dirname, './command/v1/command.proto'),
    ],
    url: '0.0.0.0:50051',
    onLoadPackageDefinition: (pkg, server) => {
      new ReflectionService(pkg).addToServer(server);
    },
  },
};


# File: src/main.ts

import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions } from '@nestjs/microservices';
import { AppModule } from './app.module';
import { grpcClientOptions } from './grpc-client.options';

async function bootstrap() {
  /**
   * This example contains a hybrid application (HTTP + gRPC)
   * You can switch to a microservice with NestFactory.createMicroservice() as follows:
   *
   * const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
   *  transport: Transport.GRPC,
   *  options: {
   *    package: 'hero',
   *    protoPath: join(__dirname, './hero/hero.proto'),
   *  }
   * });
   * await app.listen();
   *
   */
  const app = await NestFactory.create(AppModule);
  app.connectMicroservice<MicroserviceOptions>(grpcClientOptions);

  await app.startAllMicroservices();
  await app.listen(31691);
  console.log(`gRPC Server running, HTTP API on: ${await app.getUrl()}`);
}
bootstrap();


# File: tsconfig.json

{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}


# File: package.json

{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'",
    "proto:generate": "bash ./proto.sh"
  },
  "dependencies": {
    "@grpc/grpc-js": "1.14.3",
    "@grpc/reflection": "1.0.4",
    "@nestjs/common": "11.1.12",
    "@nestjs/core": "11.1.12",
    "@nestjs/microservices": "11.1.12",
    "@nestjs/platform-express": "11.1.12",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.3",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.1.2",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.3",
    "@eslint/js": "9.39.2",
    "@nestjs/cli": "11.0.16",
    "@nestjs/schematics": "11.0.9",
    "@nestjs/testing": "11.1.12",
    "@types/express": "5.0.6",
    "@types/node": "24.10.9",
    "@types/supertest": "6.0.3",
    "eslint": "9.39.2",
    "eslint-plugin-prettier": "5.5.5",
    "globals": "17.2.0",
    "jest": "30.2.0",
    "prettier": "3.8.1",
    "protobufjs": "^8.0.0",
    "supertest": "7.2.2",
    "ts-jest": "29.4.6",
    "ts-loader": "9.5.4",
    "ts-node": "10.9.2",
    "ts-proto": "^2.11.1",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.9.3",
    "typescript-eslint": "8.54.0"
  }
}
