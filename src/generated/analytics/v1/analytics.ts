// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.19.6
// source: analytics/v1/analytics.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

/** Event types for routing */
export enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0,
  /** ERROR - Urgent - upload on FAIR+ connections */
  ERROR = 1,
  /** IMPRESSION - Normal - upload on GOOD+ connections */
  IMPRESSION = 2,
  /** HEARTBEAT - Background - EXCELLENT only */
  HEARTBEAT = 3,
  /** PERFORMANCE - Background - EXCELLENT only */
  PERFORMANCE = 4,
  /** LIFECYCLE - Normal - upload on GOOD+ connections */
  LIFECYCLE = 5,
  UNRECOGNIZED = -1,
}

/** Connection quality levels */
export enum ConnectionQuality {
  CONNECTION_QUALITY_UNSPECIFIED = 0,
  /** OFFLINE - No upload */
  OFFLINE = 1,
  /** POOR - < 1 Mbps, errors only */
  POOR = 2,
  /** FAIR - 1-5 Mbps, urgent only */
  FAIR = 3,
  /** GOOD - 5-20 Mbps, normal uploads */
  GOOD = 4,
  /** EXCELLENT - > 20 Mbps, all events */
  EXCELLENT = 5,
  UNRECOGNIZED = -1,
}

/** Event = Tiny envelope + payload bytes */
export interface Event {
  /** 16-byte UUID (binary) */
  eventId: Uint8Array;
  /** 8 bytes fixed */
  timestampMs: number;
  /** Enum = 1 byte varint */
  type: EventType;
  /** 0x00MMmmPP = major.minor.patch */
  schemaVersion: number;
  /** CBOR/MsgPack/JSON encoded data */
  payload: Uint8Array;
  /** Optional: network at event time */
  network?: NetworkContext | undefined;
}

export interface Batch {
  /** 16-byte UUID */
  batchId: Uint8Array;
  /** Multiple events */
  events: Event[];
  /** 4-byte hash vs string */
  deviceFingerprint: number;
  /** Backpressure signal */
  queue?:
    | QueueStatus
    | undefined;
  /** Batch creation time */
  sentAtMs: number;
}

/** Status of the client's local event queue */
export interface QueueStatus {
  /** Number of events waiting to be sent */
  pendingEvents: number;
  /** Age of oldest pending event (hours) */
  oldestEventAgeHours: number;
  /** True if queue is growing faster than draining */
  isBackpressure: boolean;
}

export interface NetworkContext {
  quality: ConnectionQuality;
  downloadMbps: number;
  uploadMbps: number;
  /** wifi, ethernet, cellular, unknown */
  connectionType: string;
  /** For wifi/cellular */
  signalStrengthDbm: number;
}

export interface Ack {
  batchId: Uint8Array;
  accepted: boolean;
  /** 16-byte UUIDs */
  rejectedEventIds: Uint8Array[];
  /** Server backpressure */
  throttleMs: number;
  /** Updated policy (optional) */
  policy?: Policy | undefined;
}

export interface Policy {
  /** Minimum quality for uploads */
  minQuality: ConnectionQuality;
  /** Max events per batch */
  maxBatchSize: number;
  /** Force upload if older */
  maxQueueAgeHours: number;
  /** Suggested upload interval */
  uploadIntervalSeconds: number;
}

/** Analytics service - client reports events to server */

export interface AnalyticsServiceClient {
  /** Fire-and-forget batch upload (primary method) */

  ingest(request: Batch): Observable<Ack>;

  /** Optional: long-lived stream for real-time */

  stream(request: Observable<Event>): Observable<Ack>;
}

/** Analytics service - client reports events to server */

export interface AnalyticsServiceController {
  /** Fire-and-forget batch upload (primary method) */

  ingest(request: Batch): Promise<Ack> | Observable<Ack> | Ack;

  /** Optional: long-lived stream for real-time */

  stream(request: Observable<Event>): Observable<Ack>;
}

export function AnalyticsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["ingest"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = ["stream"];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ANALYTICS_SERVICE_NAME = "AnalyticsService";
