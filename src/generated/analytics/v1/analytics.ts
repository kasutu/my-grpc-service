// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.19.6
// source: analytics/v1/analytics.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

/** EventCategory categorizes the type of analytics event */
export enum EventCategory {
  EVENT_CATEGORY_UNSPECIFIED = 0,
  EVENT_CATEGORY_PLAYBACK = 1,
  EVENT_CATEGORY_ERROR = 2,
  EVENT_CATEGORY_HEALTH = 3,
  UNRECOGNIZED = -1,
}

/** ConnectionQuality represents network quality levels */
export enum ConnectionQuality {
  CONNECTION_QUALITY_UNSPECIFIED = 0,
  /** CONNECTION_QUALITY_EXCELLENT - >10 Mbps */
  CONNECTION_QUALITY_EXCELLENT = 1,
  /** CONNECTION_QUALITY_GOOD - >5 Mbps */
  CONNECTION_QUALITY_GOOD = 2,
  /** CONNECTION_QUALITY_FAIR - >1 Mbps */
  CONNECTION_QUALITY_FAIR = 3,
  /** CONNECTION_QUALITY_POOR - <1 Mbps */
  CONNECTION_QUALITY_POOR = 4,
  CONNECTION_QUALITY_OFFLINE = 5,
  UNRECOGNIZED = -1,
}

/** AnalyticsBatch represents a batch of events sent by a device */
export interface AnalyticsBatch {
  deviceId: string;
  batchId: string;
  timestampMs: number;
  events: AnalyticsEvent[];
  networkContext?: NetworkContext | undefined;
  queueStatus?: QueueStatus | undefined;
}

/** AnalyticsEvent represents a single analytics event */
export interface AnalyticsEvent {
  eventId: string;
  timestampMs: number;
  category: EventCategory;
  playback?: PlaybackEvent | undefined;
  error?: ErrorEvent | undefined;
  health?: HealthEvent | undefined;
}

/** PlaybackEvent tracks video/image campaign playback */
export interface PlaybackEvent {
  campaignId: string;
  mediaId: string;
  durationMs: number;
  completed: boolean;
}

/** ErrorEvent tracks application errors */
export interface ErrorEvent {
  errorType: string;
  message: string;
  stackTrace: string;
  component: string;
  isFatal: boolean;
}

/** HealthEvent tracks device health metrics */
export interface HealthEvent {
  batteryLevel: number;
  storageFreeBytes: number;
  cpuUsage: number;
  memoryUsage: number;
  connectionQuality: ConnectionQuality;
}

/** NetworkContext provides network conditions at upload time */
export interface NetworkContext {
  quality: ConnectionQuality;
  downloadSpeedMbps: number;
  latencyMs: number;
}

/** QueueStatus describes the device's local analytics queue state */
export interface QueueStatus {
  pendingCount: number;
  oldestEventHours: number;
}

/** BatchAck is the server's response to a batch upload */
export interface BatchAck {
  accepted: boolean;
  batchId: string;
  failedEventIds: string[];
  rejectionReason: string;
  policy?: UploadPolicy | undefined;
}

/** UploadPolicy provides server-side sync configuration to the client */
export interface UploadPolicy {
  maxBatchSize: number;
  syncIntervalSeconds: number;
  retryDelaysSeconds: number[];
}

/** AnalyticsService handles batch uploads of analytics events from devices */

export interface AnalyticsServiceClient {
  uploadBatch(request: AnalyticsBatch): Observable<BatchAck>;
}

/** AnalyticsService handles batch uploads of analytics events from devices */

export interface AnalyticsServiceController {
  uploadBatch(request: AnalyticsBatch): Promise<BatchAck> | Observable<BatchAck> | BatchAck;
}

export function AnalyticsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["uploadBatch"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ANALYTICS_SERVICE_NAME = "AnalyticsService";
