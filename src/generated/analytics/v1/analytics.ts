// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v3.19.6
// source: analytics/v1/analytics.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0,
  /** IMPRESSION - Campaign/media playback */
  IMPRESSION = 1,
  /** ERROR - Application errors */
  ERROR = 2,
  /** HEARTBEAT - Keepalive signal */
  HEARTBEAT = 3,
  /** LIFECYCLE - App start/pause/resume/stop */
  LIFECYCLE = 4,
  /** PERFORMANCE - Frame drops, memory, thermal */
  PERFORMANCE = 5,
  /** HEALTH - Device health metrics */
  HEALTH = 6,
  /** CUSTOM - Custom events (user-defined) */
  CUSTOM = 100,
  UNRECOGNIZED = -1,
}

export enum ConnectionQuality {
  CONNECTION_QUALITY_UNSPECIFIED = 0,
  OFFLINE = 1,
  /** POOR - < 1 Mbps, high latency */
  POOR = 2,
  /** FAIR - 1-5 Mbps */
  FAIR = 3,
  /** GOOD - 5-20 Mbps */
  GOOD = 4,
  /** EXCELLENT - > 20 Mbps */
  EXCELLENT = 5,
  UNRECOGNIZED = -1,
}

export enum ConnectionType {
  CONNECTION_TYPE_UNSPECIFIED = 0,
  WIFI = 1,
  ETHERNET = 2,
  CELLULAR_4G = 3,
  CELLULAR_5G = 4,
  CELLULAR_3G = 5,
  CELLULAR_2G = 6,
  UNKNOWN = 7,
  UNRECOGNIZED = -1,
}

export enum PayloadEncoding {
  PAYLOAD_ENCODING_UNSPECIFIED = 0,
  /** CBOR - Preferred: compact, typed, IETF standard */
  CBOR = 1,
  /** MSGPACK - Alternative: widely supported */
  MSGPACK = 2,
  /** JSON - Fallback: human-readable, larger */
  JSON = 3,
  UNRECOGNIZED = -1,
}

export enum CompressionAlgorithm {
  COMPRESSION_UNSPECIFIED = 0,
  NONE = 1,
  GZIP = 2,
  /** ZSTD - Preferred for speed/ratio tradeoff */
  ZSTD = 3,
  UNRECOGNIZED = -1,
}

export interface Event {
  /** 16-byte UUID (binary) - smaller than 36-char string */
  eventId: Uint8Array;
  /** Milliseconds since epoch (8 bytes fixed) - smaller than int64 varint for recent times */
  timestampMs: number;
  /** Event type for server routing */
  type: EventType;
  /**
   * Schema version as packed integer: 0x00MMmmPP = major.minor.patch
   * e.g., 0x00020000 = v2.0.0, 0x00020001 = v2.0.1
   */
  schemaVersion: number;
  /**
   * Flexible payload: CBOR (preferred), MsgPack, or compressed JSON
   * Client and server agree on encoding via schema_version
   */
  payload: Uint8Array;
  /** Optional: network context at event creation (not upload) */
  network?: NetworkContext | undefined;
}

export interface Batch {
  /** 16-byte UUID */
  batchId: Uint8Array;
  /** Multiple events in one network call */
  events: Event[];
  /** Device fingerprint (hash of stable identifiers) - 4 bytes vs string */
  deviceFingerprint: number;
  /** Client queue status for backpressure signaling */
  queue?:
    | QueueStatus
    | undefined;
  /** Client timestamp of batch creation */
  sentAtMs: number;
}

export interface QueueStatus {
  /** Pending events waiting to be sent */
  pendingCount: number;
  /** Age of oldest pending event (minutes) */
  oldestPendingMinutes: number;
  /** True if queue growing faster than draining */
  isBackpressured: boolean;
  /** Storage used by queue (KB) - for client storage pressure */
  storageKb: number;
}

export interface NetworkContext {
  quality: ConnectionQuality;
  /** Connection type encoded as small integer */
  connectionType: ConnectionType;
  /** Signal strength: -100 to 0 dBm, or 127 if unknown */
  signalDbm: number;
  /** Last measured speeds (0 if unknown) */
  downloadMbps: number;
  uploadMbps: number;
}

export interface Ack {
  /** Echo batch_id for correlation */
  batchId: Uint8Array;
  /** Accepted = stored durably (may still be processing) */
  accepted: boolean;
  /** Event IDs that failed validation (rare, payload corruption/schema mismatch) */
  rejectedEventIds: Uint8Array[];
  /**
   * Server-recommended throttle (ms before next upload)
   * 0 = no throttle, client decides
   */
  throttleMs: number;
  /** Updated policy (if server wants to change client behavior) */
  policy?: Policy | undefined;
}

export interface PolicyRequest {
  deviceFingerprint: number;
  /** For feature detection */
  sdkVersion: string;
  /** Client's max acceptable payload size */
  maxPayloadBytes: number;
}

export interface Policy {
  /** Batch sizing */
  maxEventsPerBatch: number;
  /** Max payload size server accepts */
  maxPayloadBytes: number;
  /** Timing */
  uploadIntervalSeconds: number;
  /** For errors/critical events */
  urgentIntervalSeconds: number;
  /** Quality thresholds */
  minQualityForRegular: ConnectionQuality;
  minQualityForUrgent: ConnectionQuality;
  /** Encoding preferences */
  preferredEncoding: PayloadEncoding;
  compression: CompressionAlgorithm;
  /** Circuit breaker */
  circuitOpenSeconds: number;
}

/** Empty message for stream close */
export interface Close {
}

export interface AnalyticsServiceClient {
  /**
   * Fire-and-forget batch upload (primary method)
   * Server acknowledges receipt; client doesn't block on response
   */

  ingest(request: Batch): Observable<Ack>;

  /**
   * Long-lived stream for real-time scenarios (optional)
   * Bidirectional allows server backpressure signals
   */

  stream(request: Observable<Event>): Observable<Ack>;

  /** Get current upload policy (called on startup/periodically) */

  getPolicy(request: PolicyRequest): Observable<Policy>;
}

export interface AnalyticsServiceController {
  /**
   * Fire-and-forget batch upload (primary method)
   * Server acknowledges receipt; client doesn't block on response
   */

  ingest(request: Batch): Promise<Ack> | Observable<Ack> | Ack;

  /**
   * Long-lived stream for real-time scenarios (optional)
   * Bidirectional allows server backpressure signals
   */

  stream(request: Observable<Event>): Observable<Ack>;

  /** Get current upload policy (called on startup/periodically) */

  getPolicy(request: PolicyRequest): Promise<Policy> | Observable<Policy> | Policy;
}

export function AnalyticsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["ingest", "getPolicy"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = ["stream"];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AnalyticsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ANALYTICS_SERVICE_NAME = "AnalyticsService";
